\chapter{The GitHub Way}
This chapter places GitHub in the spotlight, describing what it is, how it is used, what are some of its defining features, and why it might be used in education. GitHub exemplifies what we call is `The GitHub Way': the way in which users of GitHub and similar platforms work and collaborate. This is an important distinction, as we feel it is not just GitHub itself that can impact education, but that way of working.

\section{What is GitHub?}
GitHub is web-based social code sharing service that utilizes the Git distributed version control system. It is a tool utilized by millions of developers all over the world to facilitate collaboration via the use of its awareness and transparency features, collaborative features such as pull requests, and version control. The tool is organized so that developers can create repositories containing code, which they can cultivate on their own or share with other developers who they can collaborate on the code with. Repositories can be public, which means that anybody can see them and pull their code, though the owner can decide who can and cannot make changes; or they can be private, making the repository viewable and editable only by those given collaborator status.

\section{Git: Distributed Version Control}
There's two very important aspects to Git: that work is distributed, and that work is handled by version control. The distributed aspect refers to the possibility of work being decentralized - instead of being forced to work in a repository where there is a central hub where everyone pushes code to, individual developers can create public clones of that repository and push to their respective clones before the original repository's maintainer or owner pulls in the work. This provides many opportunities for remixing and reusing code as well as creating a workflow in which multiple parties can do separate work at their own pace.

The version control aspect means that developers can easily track changes to their code and that multiple developers can work on the same file, as combining changes requires a simple merge that Git makes very easy to handle. In this system, when a user makes changes to the project, they would `commit' their changes, effectively saving a snapshot of the project as it is at that point of time. These commits, or snapshots, are saved in history, allowing developers to revert projects back to commits as they need to. The user can then push all of their changes to the server, meaning other collaborators can see these changes made. If a collaborator has made changes as well, these can be merged together when a user `pulls' all changes made on the server.
%this will need better explaining

\section{Branching \& Forking}
Branching and forking provides two ways of diverging from the main code base. A user can make changes in a repository branch, which is a deviation of the code from the code base - the trunk - and the changes remain a part of the main repository. When a user branches off the trunk, they can still monitor changes to the trunk despite working on a different branch of it.

Forking, meanwhile, achieves a similar function of deviating from the code base. The main difference is that a fork is independent of the main code base, meaning a user won't be aware of the changes happening in the repository of the main code base unless they explicitly monitor those changes. When a user forks a repository, the repository, including all its branches, are copied; on the other hand, if a repository is deleted, the fork still exists. Generally, branching provides a good workflow for development teams, where collaborators need to be aware of all the changes made to each branch and the main code base. Meanwhile, forking tends to work for open-source projects where the repository owner does not want to manage user access to the repository and would want to keep collaborator changes independent until they are ready to be merged.

\section{Merging \& Pull Requests}
Merging is the mechanism for combining changes with each other or pulling changes in a branch of fork into the main code base. For example, a collaborator can branch or fork from the main code base and make changes to the code as they see fit, and it would remain on their branch or on their repository. In order to get the changes into the main code base, the person managing it would have to merge the changes into it, combining whatever changes were made in the branch or fork with the code base as it is. In some cases such as when the same section of code is changed at the same time, this can result in what's called a merge conflict, which would require the user to manually pick and choose which of the changes or pieces of code they want to keep. These merge conflicts would be an issue in file types that aren't versioned by Git, such as PDF documents, as changes anywhere in the file in two different branches could create merge conflicts.

Pull Requests (PRs) are a way of handling these merges. In a PR, the person making the changes in a branch or a fork will request to the code base maintainer to merge their code into the main trunk. These PRs will be listed on GitHub in a separate tab, where collaborators can see each of the commits made, what files were changed, and . Collaborators can also make comments on PRs, typically when changes have to be made before a PR should be accepted or a \'+1\' if they think a PR is ready to be merged into the main code base.

\section{Issues \& Comments}
The issues feature on GitHub allows for discussion between collaborators. These issues can be tagged with whatever the issue creator or editor wants, such as \'Bug\' or \'Feature\', and the issues list can be filtered to only see issues of a certain tag, or see only closed or open issues. Issues can be assigned to a user, letting others know who is in charge of that issue. As well, issues can be assigned to a Milestone, a date set by a collaborator to have certain issues completed by. PRs also get automatically posted as an issue, which gets closed when that PR gets accepted or closed. Users can comment on issues, so the issues can be used as a hub for discussions. Users can also refer to issues in commit messages, thereby displaying it in the issue: for example, an issue #11 would say \textit{``this issue has been referred to by commit #afeoai183ja.''}

Moreover, an important feature is in the flexibility in the comments made. For example, users can mention others by referring to their username preceded by an \'@\' character, thereby sending them a notification and, in most cases, an email. This allows collaborators to directly refer to another when, for example, they'd like to ask someone to make a specific change to the issue or PR. Comments can also refer to specific commits by using their \'#\' commit number, or to specific issues or PRs by using their issue number preceded by the character \'#\'. Users can also comment on more specific artifacts, such as pull requests, commits, or lines of code. This gives the user flexibility in being able to warn another collaborator, for example, when a specific line of code is difficult to understand or causes a bug.
%fact check the referring to specific commits

\section{Openness \& Transparency}
GitHub's openness and transparency features allows groups to facilitate both direct and indirect collaboration, allowing users to have a full view of things going on in the project. For example, users can look at the commit history to see exactly what the other collaborators are working on and changing, as they are able to see specific changes on specific commits. This history is useful, compounded by the use of the \'blame\' feature, in which a user can see exactly who made a specific change or line of code. %why is this useful

Users can also choose to \'Watch\' a repository, 

Activity monitor.

News feed.

\section{Why GitHub for Education?}
%mention education.github.com
